# VitalFlow: Real-Time CGM Insights for Proactive Diabetes Management

## Project Purpose

VitalFlow is a mobile application designed to empower individuals with diabetes by providing seamless, real-time tracking of blood glucose levels through Continuous Glucose Monitors (CGMs). Leveraging advanced AI and a user-centric design, VitalFlow aims to offer personalized, actionable insights that enable proactive management of diabetes, improving overall health outcomes and quality of life.

## Technology Stack Justification

Our technology stack is carefully selected to address the identified market gaps and provide a competitive advantage:

*   **Frontend: React Native**
    *   **Addresses Market Gap:** Intuitive and Uncluttered User Interface, Broad CGM Integration.
    *   **Justification:** React Native allows us to build a single codebase for both iOS and Android, significantly speeding up development and ensuring a consistent, high-quality user experience across platforms. Its component-based architecture facilitates the creation of a clean, uncluttered interface that prioritizes ease of use and clear data visualization, directly tackling the weakness of cluttered interfaces seen in competitors like Glucose Buddy. The framework's performance is well-suited for handling real-time data streams from CGMs, enabling the core functionality of continuous monitoring.

*   **Backend: Node.js with Express.js**
    *   **Addresses Market Gap:** Broad and Effortless Real-Time CGM Integration, Actionable Insights.
    *   **Justification:** Node.js's asynchronous, event-driven nature makes it exceptionally efficient for handling the continuous, real-time data ingestion from various CGM devices. This directly addresses the lack of real-time monitoring highlighted in Diabetes:M. Express.js provides a lightweight framework to build robust APIs for data processing, AI model integration, and secure communication, crucial for delivering personalized insights and managing diverse CGM data streams.

*   **Database: PostgreSQL**
    *   **Addresses Market Gap:** Broad and Effortless Real-Time CGM Integration, Data Accessibility.
    *   **Justification:** PostgreSQL is a powerful relational database that excels at managing structured data, including time-series data generated by CGMs. Its reliability ensures data integrity, while features like JSONB support offer flexibility for storing diverse data points and user-specific information. This robustness is key for accurate tracking and analysis required for personalized insights.

*   **AI/ML: Python (TensorFlow/PyTorch, Scikit-learn)**
    *   **Addresses Market Gap:** Actionable, Personalized Insights.
    *   **Justification:** Python's rich ecosystem of machine learning libraries allows us to develop sophisticated algorithms for predictive analytics, trend identification, and personalized recommendations. These insights, derived from real-time CGM data, will provide users with actionable guidance that current competitors largely lack, particularly in a real-time, integrated manner.

*   **Cloud/Deployment: AWS**
    *   **Addresses Market Gap:** Scalability, Reliability.
    *   **Justification:** AWS provides a scalable and reliable cloud infrastructure necessary to handle potentially large volumes of real-time data and user growth. Managed services reduce operational overhead, allowing the team to focus on feature development and AI model refinement.

## Project Structure Overview

The project follows a standard React Native structure, organized for maintainability and scalability:

*   `android/` & `ios/`: Native project files for respective platforms.
*   `src/`: Contains all application source code.
    *   `api/`: Handles all backend API interactions and configurations.
    *   `assets/`: Stores static assets like fonts, images, and global styles.
    *   `components/`: Reusable UI components, categorized by type (common, cgm-specific, dashboard).
    *   `config/`: Application configuration files.
    *   `hooks/`: Custom React hooks for reusable logic.
    *   `navigation/`: Defines the app's navigation structure.
    *   `screens/`: Top-level components representing application screens, organized by feature.
    *   `services/`: Business logic for interacting with APIs and managing data flow.
    *   `store/`: State management using a pattern like Redux or Zustand.
    *   `utils/`: Helper functions and utility classes.
*   `tests/`: Contains unit and integration tests.
*   Root files (`.env`, `.gitignore`, `package.json`, etc.): Configuration and project metadata.

This structure promotes modularity, making it easier to develop, test, and maintain the application as it grows and evolves.
